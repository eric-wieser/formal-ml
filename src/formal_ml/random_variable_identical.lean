/-
Copyright 2021 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 -/
import measure_theory.measurable_space

import measure_theory.measure_space
import measure_theory.outer_measure
import measure_theory.lebesgue_measure
import measure_theory.integration

import measure_theory.borel_space
import data.set.countable
import formal_ml.nnreal
import formal_ml.sum
import formal_ml.lattice
import formal_ml.measurable_space
import formal_ml.classical
import data.equiv.list
import formal_ml.prod_measure
import formal_ml.finite_pi_measure
import formal_ml.probability_space
import formal_ml.monotone_class

/-!
  This file focuses on more esoteric proofs that random variables are identical.
  In particular, given two random variables X Y with a common measurable space as a codomain,
  where the codomain is generated by some set of measurable sets S.
  X and Y are identical if they are identical on measurable sets in S, assuming S
  has some particular properties. The first is that S is an algebra, i.e. S has the 
  universal set and is closed under set difference.

  An alternative is that S is (basically) a semi-algebra, i.e. it has the empty set 
  and is closed under intersection, and semi-closed under complement. Normally, a 
  semi-algebra would require the universal set, but that is not required for this
  purpose.

  This is most useful for proving independent and identical random variables, when
  considered as an aggregate random variable, are identical.

  The core is the monotone class theorem, measurable_space.generate_from_monotone_class.
-/

lemma random_variable_identical_on_algebra''' {Ω₁ Ω₂ α:Type*} (s: set (set α))
  (A:s.is_algebra)
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from s)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from s)}:
  (∀ (T:measurable_setB (measurable_space.generate_from s)), 
   T.val ∈ s → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h3 U,
  cases U,
  have AM := A.monotone_class,
  have h7:∀ {T':set α}, s.monotone_class T' →
          (measurable_space.generate_from s).measurable_set' T',
  { intros T h7_1,
    rw measurable_space.generate_from_monotone_class at h7_1,
    simp [measurable_space.generate_from],
    apply h7_1, apply A },
  have h4:measurable_space.generate_measurable s U_val,
  { simp [measurable_space.generate_from] at U_property,
    apply U_property },
  have h5:s.monotone_class U_val,
  { rw measurable_space.generate_from_monotone_class,
    apply h4, apply A },
  induction h5 with U' h_U' f h_rec h_mono h_ind f h_rec h_mono h_ind,
  { apply h3, apply h_U' },
  { have h6:(∀ᵣ i, X₁ ∈ᵣ ⟨f i, h7 (h_rec i)⟩) = (X₁ ∈ᵣ ⟨set.Inter f, U_property⟩) ,
    { apply event.eq, simp, ext ω, split; intros h6_1; simp at h6_1; simp [h6_1], },
    rw ← h6,
    have h7:(∀ᵣ i, X₂ ∈ᵣ ⟨f i, h7 (h_rec i)⟩) = (X₂ ∈ᵣ ⟨set.Inter f, U_property⟩) ,
    { apply event.eq, simp, ext ω, split; intros h7_1; simp at h7_1; simp [h7_1], },
    rw ← h7,
    rw Pr_forall_revent_eq_infi,
    rw Pr_forall_revent_eq_infi,
    have h8:(λ (i : ℕ), Pr[X₁ ∈ᵣ ⟨f i, _⟩]) = λ (i : ℕ), Pr[X₂ ∈ᵣ ⟨f i, _⟩],
    { ext1 i, apply h_ind, 
      rw ← measurable_space.generate_from_monotone_class,
      apply h_rec, apply A },
    rw h8,
    simp, apply h_mono,
    simp, apply h_mono },
  { have h9:(∃ᵣ i, X₁ ∈ᵣ ⟨f i, h7 (h_rec i)⟩) = (X₁ ∈ᵣ ⟨set.Union f, U_property⟩) ,
    { apply event.eq, simp, ext ω, split; intros h9_1; simp at h9_1; simp [h9_1], },
    rw ← h9,
    have h10:(∃ᵣ i, X₂ ∈ᵣ ⟨f i, h7 (h_rec i)⟩) = (X₂ ∈ᵣ ⟨set.Union f, U_property⟩) ,
    { apply event.eq, simp, ext ω, split; intros h10_1; simp at h10_1; simp [h10_1] },
    rw ← h10,
    rw Pr_exists_revent_eq_supr,
    rw Pr_exists_revent_eq_supr,
    have h11:(λ (i : ℕ), Pr[X₁ ∈ᵣ ⟨f i, _⟩]) = λ (i : ℕ), Pr[X₂ ∈ᵣ ⟨f i, _⟩],
    { ext1 i, apply h_ind, 
      rw ← measurable_space.generate_from_monotone_class,
      apply h_rec, apply A },
    rw h11,
    simp, apply h_mono,
    simp, apply h_mono },
end

lemma random_variable_identical_on_algebra {Ω₁ Ω₂ α:Type*} (s: set (set α))
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from s)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from s)}:
  (set.univ ∈ s) →
  (∀ a b, a∈ s → b ∈ s → a \ b ∈ s) →
  (∀ (T:measurable_setB (measurable_space.generate_from s)), 
   T.val ∈ s → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h3,
  apply random_variable_identical_on_algebra''',
  apply set.is_algebra.mk h1 h2,
  apply h3,
end



/- This allows for the measurable space to be generated from a different
   set. -/
lemma random_variable_identical_on_algebra' {Ω₁ Ω₂ α:Type*} (s: set (set α))
  (M:measurable_space α)
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ M}
  {X₂:P₂ →ᵣ M}:
  (set.univ ∈ s) →
  (∀ a b, a∈ s → b ∈ s → a \ b ∈ s) →
  (M = measurable_space.generate_from s) →
  (∀ (T:measurable_setB M), 
   T.val ∈ s → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h3 h4 T',
  tactic.unfreeze_local_instances,
  subst M,
  apply random_variable_identical_on_algebra,
  apply h1,
  apply h2,
  apply h4,
end

#check measurable_space.generate_from
lemma random_variable_identical_on_algebra'' {Ω₁ Ω₂ α:Type*} (s t: set (set α))
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from t)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from t)}:
  (set.univ ∈ s) →
  (∀ a b, a∈ s → b ∈ s → a \ b ∈ s) →
  (t ⊆ s) →
  (∀ a∈ s, (measurable_space.generate_from t).measurable_set' a) →
  (∀ (T:measurable_setB (measurable_space.generate_from t)), 
   T.val ∈ s → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h3 h4 h5,
  have h6:(measurable_space.generate_from t) = (measurable_space.generate_from s),
  { apply le_antisymm;
    apply measurable_space.generate_from_le;
    intros a h_a,
    { simp [measurable_space.generate_from],
      apply measurable_space.generate_measurable.basic,
      apply h3, apply h_a },
    apply h4, apply h_a },
  apply random_variable_identical_on_algebra',
  apply h1,
  apply h2,
  apply h6,
  apply h5,
end

lemma equality_disjoint_union_closure {Ω₁ Ω₂ α:Type*} (S : set (set α))
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from S)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from S)}:
  (∀ (T:measurable_setB (measurable_space.generate_from S)), 
   T.val ∈ S → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  (∀ (T:measurable_setB (measurable_space.generate_from S)),
   T.val ∈ S.disjoint_union_closure → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) :=
begin
  intros h4,
  intros T h_T, cases T,
    rw set.mem_disjoint_union_closure_iff at h_T,
    cases h_T with m h_T,
    cases h_T with f h_T,
    cases h_T with h_f h_T,
    cases h_T with h_f_pairwise h_s_def,
    simp at h_s_def,
    subst T_val,
    have h_X1:X₁ ∈ᵣ ⟨set.Union f, T_property⟩ = (eany (λ (i:fin m), X₁ ∈ᵣ ⟨f i, 
             measurable_space.measurable_set_generate_from (h_f i)⟩)),
    { apply event.eq, ext ω, split; intros h_X1_1; simp at h_X1_1; cases h_X1_1 with i
      h_X1_1; simp [h_X1_1]; apply exists.intro i; apply h_X1_1 },
    have h_X2:X₂ ∈ᵣ ⟨set.Union f, T_property⟩ = (eany (λ (i:fin m), X₂ ∈ᵣ ⟨f i, 
             measurable_space.measurable_set_generate_from (h_f i)⟩)),
    { apply event.eq, ext ω, split; intros h_X1_1; simp at h_X1_1; cases h_X1_1 with i
      h_X1_1; simp [h_X1_1]; apply exists.intro i; apply h_X1_1 },
    rw h_X1, rw h_X2,
    rw Pr_eany_sum,
    rw Pr_eany_sum,
    { congr, ext1 b, apply h4, simp, apply h_f },
    { intros i j h_ne, simp only [function.on_fun], apply disjoint_preimage, 
      apply h_f_pairwise, apply h_ne },
    { intros i j h_ne, simp only [function.on_fun], apply disjoint_preimage, 
      apply h_f_pairwise, apply h_ne },
end


#check 3
#check 3


lemma random_variable_identical_on_semialgebra''' {Ω₁ Ω₂ α:Type*} (S : set (set α))
  (A:S.is_semialgebra)
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from S)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from S)}:
  (∀ (T:measurable_setB (measurable_space.generate_from S)), 
   T.val ∈ S → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h4,
  have CA := A.disjoint_union_closure,
  
  apply random_variable_identical_on_algebra'' S.disjoint_union_closure,
  { apply CA.univ },
  { apply CA.diff },
  { intros a h_a, apply set.disjoint_union_closure_self, apply h_a  },
  { intros s h_s,
    rw set.mem_disjoint_union_closure_iff at h_s,
    cases h_s with m h_s,
    cases h_s with f h_s,
    cases h_s with h_f h_s,
    cases h_s with h_f_pairwise h_s_def,
    subst s,
    haveI:fintype (fin m) := fin.fintype m,
    haveI:encodable (fin m) := fintype.encodable (fin m),
    simp, apply measurable_set.Union, 
    intro b, apply measurable_space.measurable_set_generate_from,
    apply h_f },
  { apply equality_disjoint_union_closure,
    apply h4 },
end

#check 12
#check 3


lemma random_variable_identical_on_semialgebra {Ω₁ Ω₂ α:Type*} (S : set (set α))
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from S)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from S)}:
  (∀ s t∈ S, s ∩ t ∈ S) →
  (∀ s ∈ S, sᶜ ∈ S.disjoint_union_closure) →  
  (∅ ∈ S) →
  (@set.univ α ∈ S) →
  (∀ (T:measurable_setB (measurable_space.generate_from S)), 
   T.val ∈ S → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h3 h_univ h4,
  have A := set.is_semialgebra.mk h_univ h3 h1 h2,
  apply random_variable_identical_on_semialgebra''',
  apply A,
  apply h4,
end


/- TODO: technically, could remove empty set or the universe, and it would
   still be true. -/
lemma random_variable_identical_on_semialgebra' {Ω₁ Ω₂ α:Type*} (S : set (set α))
  (M:measurable_space α)
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ M}
  {X₂:P₂ →ᵣ M}:
  (∀ s t∈ S, s ∩ t ∈ S) →
  (∀ s ∈ S, sᶜ ∈ S.disjoint_union_closure) →  
  (∅ ∈ S) →
  (set.univ ∈ S) →
  (M = measurable_space.generate_from S) →
  (∀ (T:measurable_setB M), 
   T.val ∈ S → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h3 h_univ h4 h5,
  tactic.unfreeze_local_instances,
  subst M,
  apply random_variable_identical_on_semialgebra,
  apply h1,
  apply h2,
  apply h3,
  apply h_univ,
  apply h5,
end

lemma random_variable_identical_on_semialgebra'' {Ω₁ Ω₂ α:Type*} (s t: set (set α))
  {P₁:probability_space Ω₁} {P₂:probability_space Ω₂} 
  {X₁:P₁ →ᵣ (measurable_space.generate_from t)}
  {X₂:P₂ →ᵣ (measurable_space.generate_from t)}:
  (∀ a b∈ s, a ∩ b ∈ s) →
  (∀ a ∈ s, aᶜ ∈ s.disjoint_union_closure) →  
  (∅ ∈ s) →
  (set.univ ∈ s) →
  (t ⊆ s) →
  (∀ a∈ s, (measurable_space.generate_from t).measurable_set' a) →
  (∀ (T:measurable_setB (measurable_space.generate_from t)), 
   T.val ∈ s → Pr[X₁ ∈ᵣ T] = Pr[X₂ ∈ᵣ T]) → 
  random_variable_identical X₁ X₂ :=
begin
  intros h1 h2 h_empty h_univ h3 h4 h5,
  have h6:(measurable_space.generate_from t) = (measurable_space.generate_from s),
  { apply le_antisymm;
    apply measurable_space.generate_from_le;
    intros a h_a,
    { simp [measurable_space.generate_from],
      apply measurable_space.generate_measurable.basic,
      apply h3, apply h_a },
    apply h4, apply h_a },
  apply random_variable_identical_on_semialgebra',
  apply h1,
  apply h2,
  apply h_empty,
  apply h_univ,
  apply h6,
  apply h5,
end





